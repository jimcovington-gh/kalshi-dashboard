"""
Lambda function to monitor Kalshi API changelog for breaking changes.
Runs weekly (Monday) to check for upcoming changes in Thursday releases.
"""
import json
import logging
import os
import re
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import urllib.request
import urllib.error
from html.parser import HTMLParser

import boto3

logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Environment variables
SNS_TOPIC_ARN = os.environ.get('SNS_TOPIC_ARN', '')


class ChangelogParser(HTMLParser):
    """Parse Kalshi API changelog HTML to extract breaking changes."""
    
    def __init__(self):
        super().__init__()
        self.in_breaking_change = False
        self.current_date = None
        self.current_text = []
        self.breaking_changes = []
        self.in_date_header = False
        
    def handle_starttag(self, tag, attrs):
        if tag in ['h2', 'h3']:
            self.in_date_header = True
            self.current_text = []
            
    def handle_endtag(self, tag):
        if tag in ['h2', 'h3'] and self.in_date_header:
            self.in_date_header = False
            text = ''.join(self.current_text).strip()
            
            # Check if this is a date header
            date_match = re.search(r'([A-Za-z]+\s+\d{1,2},\s+\d{4})', text)
            if date_match:
                self.current_date = date_match.group(1)
                
            # Check if this is a breaking change
            if 'breaking' in text.lower():
                self.in_breaking_change = True
                if self.current_date:
                    self.breaking_changes.append({
                        'date': self.current_date,
                        'title': text,
                        'details': []
                    })
                    
        elif tag == 'p' and self.in_breaking_change and self.current_text:
            text = ''.join(self.current_text).strip()
            if text and self.breaking_changes:
                self.breaking_changes[-1]['details'].append(text)
            self.current_text = []
            
    def handle_data(self, data):
        if self.in_date_header or self.in_breaking_change:
            self.current_text.append(data)


def fetch_changelog() -> str:
    """Fetch the Kalshi API changelog page."""
    url = 'https://docs.kalshi.com/changelog'
    
    try:
        req = urllib.request.Request(
            url,
            headers={'User-Agent': 'Kalshi-Changelog-Monitor/1.0'}
        )
        with urllib.request.urlopen(req, timeout=10) as response:
            return response.read().decode('utf-8')
    except urllib.error.URLError as e:
        logger.error(f"Failed to fetch changelog: {e}")
        raise


def parse_changelog(html: str) -> List[Dict[str, Any]]:
    """Parse HTML changelog to extract breaking changes."""
    parser = ChangelogParser()
    parser.feed(html)
    return parser.breaking_changes


def filter_upcoming_changes(changes: List[Dict[str, Any]], days_ahead: int = 14) -> List[Dict[str, Any]]:
    """Filter breaking changes happening within the next N days."""
    upcoming = []
    now = datetime.utcnow()
    cutoff = now + timedelta(days=days_ahead)
    
    for change in changes:
        try:
            # Parse date from changelog (e.g., "November 7, 2025")
            change_date = datetime.strptime(change['date'], '%B %d, %Y')
            
            # Look for "Expected release" date in details
            expected_release = None
            for detail in change['details']:
                release_match = re.search(r'Expected release:\s*([A-Za-z]+\s+\d{1,2},\s+\d{4})', detail)
                if release_match:
                    expected_release = datetime.strptime(release_match.group(1), '%B %d, %Y')
                    break
            
            # Use expected release date if available, otherwise use announcement date
            check_date = expected_release if expected_release else change_date
            
            # Include if it's in the future and within our window
            if now <= check_date <= cutoff:
                change['release_date'] = check_date.strftime('%B %d, %Y')
                change['days_until'] = (check_date - now).days
                upcoming.append(change)
                
        except ValueError as e:
            logger.warning(f"Could not parse date from change: {change.get('date')} - {e}")
            continue
    
    return upcoming


def send_notification(changes: List[Dict[str, Any]]) -> None:
    """Send SNS notification about upcoming breaking changes."""
    if not SNS_TOPIC_ARN:
        logger.warning("SNS_TOPIC_ARN not configured, skipping notification")
        return
    
    if not changes:
        logger.info("No upcoming breaking changes found")
        return
    
    # Build notification message
    subject = f"‚ö†Ô∏è Kalshi API: {len(changes)} Breaking Change(s) Coming Soon"
    
    message_parts = [
        "Upcoming Kalshi API Breaking Changes",
        "=" * 50,
        ""
    ]
    
    for change in sorted(changes, key=lambda x: x['days_until']):
        message_parts.extend([
            f"üìÖ {change['release_date']} ({change['days_until']} days)",
            f"üìã {change['title']}",
            ""
        ])
        
        for detail in change['details'][:3]:  # First 3 details
            message_parts.append(f"   {detail}")
        
        message_parts.extend(["", "-" * 50, ""])
    
    message_parts.extend([
        "",
        "üîó Full changelog: https://docs.kalshi.com/changelog",
        "",
        "‚ö° Action required: Review these changes and update code before release date."
    ])
    
    message = "\n".join(message_parts)
    
    # Send SNS notification
    sns = boto3.client('sns')
    try:
        response = sns.publish(
            TopicArn=SNS_TOPIC_ARN,
            Subject=subject,
            Message=message
        )
        logger.info(f"Notification sent: {response['MessageId']}")
    except Exception as e:
        logger.error(f"Failed to send SNS notification: {e}")
        raise


def lambda_handler(event, context):
    """
    Lambda handler to check Kalshi API changelog for breaking changes.
    
    Runs weekly to check for upcoming API changes.
    Sends SNS notification if breaking changes are found.
    """
    logger.info("Changelog monitor started")
    
    try:
        # Fetch and parse changelog
        logger.info("Fetching Kalshi API changelog")
        html = fetch_changelog()
        
        logger.info("Parsing changelog for breaking changes")
        all_changes = parse_changelog(html)
        logger.info(f"Found {len(all_changes)} total breaking changes in changelog")
        
        # Filter for upcoming changes (next 14 days)
        upcoming_changes = filter_upcoming_changes(all_changes, days_ahead=14)
        logger.info(f"Found {len(upcoming_changes)} upcoming breaking changes")
        
        # Log details
        for change in upcoming_changes:
            logger.info(
                f"Upcoming change: {change['release_date']} "
                f"({change['days_until']} days) - {change['title']}"
            )
        
        # Send notification
        send_notification(upcoming_changes)
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'message': 'Changelog check completed',
                'total_breaking_changes': len(all_changes),
                'upcoming_changes': len(upcoming_changes),
                'changes': upcoming_changes
            })
        }
        
    except Exception as e:
        logger.error(f"Changelog monitor failed: {e}", exc_info=True)
        return {
            'statusCode': 500,
            'body': json.dumps({
                'error': str(e)
            })
        }


if __name__ == '__main__':
    # For local testing
    import sys
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    result = lambda_handler({}, None)
    print(json.dumps(result, indent=2))
